import numpy as np
import math
import matplotlib.pyplot as plt
import matplotlib.pylab as pylab

pylab.rcParams["figure.figsize"] = 10, 10


# #### Helpful Equations
#
# $$F_z = m \ddot{z}$$
#
# $$M_z = I_z \ddot{\psi}$$
#
# $$ \ddot{z} = g- \frac{k_f}{m}\left( \omega_1^2 +\omega_2^2 \right)   \\
#    \ddot{\psi} =\frac{k_m}{I_z} (-\omega_1^2 + \omega_2^2 )  $$


class Coaxial:
  def __init__(self, k_f=0.1, k_m=0.1, m=0.5, i_z=0.2):
    self.k_f = k_f
    self.k_m = k_m
    self.m = m
    self.i_z = i_z

    self.omega_1 = 0.0
    self.omega_2 = 0.0
    self.g = 9.81

  @property
  def z_dot_dot(self):
    """Calculates current vertical acceleration."""

    # TODO:
    # 1. Calculate the lift force generated by the first
    #    and second propellers
    # 2. Calculate the total vertical force acting on the drone
    # 3. Calculate the vertical acceleration due to the
    #    total force acting on the drone keep in mind that the
    #    z-axis is directed downward

    f_1 = self.k_f * self.omega_1**2
    f_2 = self.k_f * self.omega_2**2
    f_g = self.m * self.g
    f_total = -f_1 - f_2 + f_g

    acceleration = f_total / self.m

    return acceleration

  @property
  def psi_dot_dot(self):
      """Calculates current rotational acceleration."""
      # TODO:
      # 1. Calculate the torques generated by both propellers
      # 2. Calculate the angular acceleration

      cw_torque = self.k_m * self.omega_1**2
      ccw_torque = self.k_m * self.omega_2**2

      net_torque = cw_torque - ccw_torque
      angular_acc = net_torque / self.i_z

      return angular_acc

  def set_rotors_angular_velocities(self, linear_acc, angular_acc):
      """
      Sets the turn rates for the rotors so that the drone
      achieves the desired linear_acc and angular_acc.
      """

      # TODO
      # 1. Calculate the correct values of omega_1 and omega_2
      # 2. Set self.omega_1 and self.omega_2 to those values
      # 3. Don't forget to return omega_1, omega_2

      term_1 = self.m * (-linear_acc + self.g) / (2 * self.k_f)
      term_2 = self.i_z * angular_acc / (2 * self.k_m)

      omega_1 = math.sqrt(term_1 - term_2)
      omega_2 = math.sqrt(term_1 + term_2)

      self.omega_1 = -omega_1
      self.omega_2 = omega_2

      return self.omega_1, self.omega_2

# TEST CODE 1

bi = CoaxialCopter()
stable_omega_1, stable_omega_2 = bi.set_rotors_angular_velocities(0.0, 0.0)

print(
    "Drone achieves stable hover with angular velocity of %5.2f" % stable_omega_1,
    "for the first propeller and %5.2f" % stable_omega_2,
    "for the second propeller.",
)

# TEST CODE 2 - Checking the linear acceleration value

bi.omega_1 = stable_omega_1 * math.sqrt(1.1)
bi.omega_2 = stable_omega_2 * math.sqrt(1.1)

vertical_acceleration = bi.z_dot_dot
print(
    "Increase by %5.2f" % math.sqrt(1.1),
    "of the propeller angular velocity will result in",
    "%5.2f" % vertical_acceleration,
    "m/(s*s) vertical acceleration.",
)

# TEST CODE 3 - checking the angular acceleration
bi.omega_1 = stable_omega_1 * math.sqrt(1.1)
bi.omega_2 = stable_omega_2 * math.sqrt(0.9)

ang_acceleration = bi.psi_dot_dot
print(
    "Increase in %5.2f" % math.sqrt(1.1),
    " of the angular velocity for the first propeller and",
    " decrease of the angular velocity of the second propeller by %f.2f"
    % math.sqrt(0.9),
    " will result in",
    "%5.2f" % ang_acceleration,
    "rad/(s*s) angular acceleration.",
)
